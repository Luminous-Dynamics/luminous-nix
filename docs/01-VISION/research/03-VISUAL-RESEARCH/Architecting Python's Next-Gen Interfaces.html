<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infographic: Python's Advanced UI Frameworks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 400px;
        }
        @media (max-width: 768px) {
            .chart-container {
                height: 300px;
            }
        }
        .flowchart-node {
            border: 2px solid;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 600;
            min-height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .flowchart-arrow {
            position: relative;
            width: 100%;
            height: 2px;
            margin: 1.5rem 0;
        }
        .flowchart-arrow::after {
            content: '‚ñº';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -2.1rem;
            top: 50%;
            transform: translateY(-50%);
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            border-width: 4px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <header class="bg-[#003f5c] text-white p-4 shadow-lg sticky top-0 z-50">
        <nav class="container mx-auto flex justify-center items-center space-x-4 md:space-x-8 text-sm md:text-base">
            <a href="#tui" class="hover:text-[#ffa600] transition-colors duration-300 font-semibold">Textual TUI</a>
            <a href="#voice" class="hover:text-[#ffa600] transition-colors duration-300 font-semibold">Voice Pipeline</a>
            <a href="#embodied" class="hover:text-[#ffa600] transition-colors duration-300 font-semibold">Embodied AI</a>
            <a href="#roadmap" class="hover:text-[#ffa600] transition-colors duration-300 font-semibold">Roadmap</a>
        </nav>
    </header>

    <main class="container mx-auto p-4 md:p-8">

        <section class="text-center mb-16">
            <h1 class="text-4xl md:text-5xl font-black text-[#003f5c] mb-4">Architecting Python's Next-Gen Interfaces</h1>
            <p class="text-lg md:text-xl max-w-3xl mx-auto text-gray-600">A visual deep-dive into the frameworks and libraries shaping the future of user experience for headless engines, from rich terminal apps to conversational AI.</p>
        </section>

        <section id="tui" class="mb-16 scroll-mt-24">
            <div class="text-center mb-12">
                <h2 class="text-3xl font-bold text-[#003f5c]">I. The Modern Terminal with Textual</h2>
                <p class="mt-2 text-gray-600 max-w-2xl mx-auto">Elevating the command-line from a simple tool to a beautiful, interactive application requires a paradigm shift. Textual offers a web-inspired, asynchronous framework to build best-in-class TUIs.</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-xl font-bold text-center mb-4 text-[#003f5c]">TUI Framework Feature Comparison</h3>
                    <p class="text-sm text-gray-600 text-center mb-4">Textual introduces modern, web-like features such as CSS-based styling and native async support, setting it apart from traditional, procedural TUI libraries.</p>
                    <div class="chart-container">
                        <canvas id="tuiComparisonChart"></canvas>
                    </div>
                </div>

                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-xl font-bold text-center mb-4 text-[#003f5c]">Textual's Core Paradigm</h3>
                    <p class="text-sm text-gray-600 text-center mb-4">Adopting Textual means embracing its web development DNA. Its architecture is built on asynchronous event handling and declarative styling with Terminal CSS (TCSS).</p>
                    <div class="chart-container h-[300px] md:h-[350px]">
                        <canvas id="textualParadigmChart"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <section id="voice" class="mb-16 scroll-mt-24">
            <div class="text-center mb-12">
                <h2 class="text-3xl font-bold text-[#7a5195]">II. Low-Latency Conversational Voice</h2>
                <p class="mt-2 text-gray-600 max-w-2xl mx-auto">Building a voice interface that feels natural and not robotic requires careful orchestration of multiple components, where every millisecond of latency matters.</p>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-3 bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-xl font-bold text-center mb-4 text-[#7a5195]">Anatomy of Voice Pipeline Latency</h3>
                    <p class="text-sm text-gray-600 text-center mb-4">Conversational lag is a cumulative effect. While VAD is nearly instant, the Speech-to-Text (STT) processing is typically the largest bottleneck in the pipeline.</p>
                    <div class="chart-container">
                        <canvas id="latencyChart"></canvas>
                    </div>
                </div>
                <div class="lg:col-span-2 bg-white rounded-lg shadow-md p-6 flex flex-col justify-center">
                    <h3 class="text-xl font-bold text-center mb-4 text-[#7a5195]">Key Orchestration Patterns</h3>
                    <p class="text-sm text-gray-600 text-center mb-6">Connecting the components requires a robust framework. `pipecat` offers a unified, "batteries-included" solution, while `Wyoming` enables a powerful, distributed microservice architecture.</p>
                    <div class="space-y-4">
                        <div class="text-center">
                            <h4 class="font-bold text-[#374c80]">Pipecat (Unified)</h4>
                            <p class="text-xs text-gray-500">Single application, rapid development.</p>
                        </div>
                        <div class="text-center">
                            <h4 class="font-bold text-[#bc5090]">Wyoming (Distributed)</h4>
                            <p class="text-xs text-gray-500">High performance, scalable services.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-8 bg-white rounded-lg shadow-md p-6">
                 <h3 class="text-xl font-bold text-center mb-6 text-[#7a5195]">Real-time Data Flow Architecture</h3>
                 <p class="text-sm text-gray-600 text-center mb-8">This flowchart illustrates the critical path of audio data, from raw microphone input to synthesized speech output, managed by an orchestration layer.</p>
                 <div class="flex flex-col items-center">
                    <div class="flowchart-node bg-blue-100 text-blue-800 border-blue-500">üéôÔ∏è PyAudio Capture (30ms chunks)</div>
                    <div class="flowchart-arrow text-blue-500"></div>
                    <div class="flowchart-node bg-green-100 text-green-800 border-green-500">üëÇ webrtcvad (Voice Activity Detection)</div>
                    <div class="flowchart-arrow text-green-500"></div>
                    <div class="flowchart-node bg-purple-100 text-purple-800 border-purple-500">üß† Whisper STT (Speech-to-Text)</div>
                    <div class="flowchart-arrow text-purple-500"></div>
                    <div class="flowchart-node bg-orange-100 text-orange-800 border-orange-500">ü§ñ Headless Engine (Core Logic)</div>
                    <div class="flowchart-arrow text-orange-500"></div>
                    <div class="flowchart-node bg-red-100 text-red-800 border-red-500">üó£Ô∏è Piper TTS (Text-to-Speech)</div>
                    <div class="flowchart-arrow text-red-500"></div>
                    <div class="flowchart-node bg-blue-100 text-blue-800 border-blue-500">üîä PyAudio Playback</div>
                 </div>
            </div>
        </section>

        <section id="embodied" class="mb-16 scroll-mt-24">
            <div class="text-center mb-12">
                <h2 class="text-3xl font-bold text-[#ef5675]">III. Prototyping Embodied AI</h2>
                <p class="mt-2 text-gray-600 max-w-2xl mx-auto">Validating the long-term vision of a visual, embodied AI requires a clear separation of concerns: `Pygame` for presentation and `Taichi` for high-performance, GPU-accelerated computation.</p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-xl font-bold text-center mb-6 text-[#ef5675]">Division of Responsibilities</h3>
                    <p class="text-sm text-gray-600 text-center mb-6">A clean architecture is key. Pygame manages the window and user input, while Taichi handles all heavy lifting for physics simulation and rendering on the GPU.</p>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm text-left">
                            <thead class="bg-red-100 text-red-800">
                                <tr>
                                    <th class="p-3 font-semibold">Responsibility</th>
                                    <th class="p-3 font-semibold">Library</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="border-b"><td class="p-3">Windowing & Display</td><td class="p-3 font-mono bg-gray-50">Pygame</td></tr>
                                <tr class="border-b"><td class="p-3">User Input Events</td><td class="p-3 font-mono bg-gray-50">Pygame</td></tr>
                                <tr class="border-b"><td class="p-3 font-semibold text-red-600">Particle Physics Simulation</td><td class="p-3 font-mono bg-red-50 text-red-600">Taichi (GPU)</td></tr>
                                <tr class="border-b"><td class="p-3 font-semibold text-red-600">Rendering to Pixel Buffer</td><td class="p-3 font-mono bg-red-50 text-red-600">Taichi (GPU)</td></tr>
                                <tr class="border-b"><td class="p-3">CPU-GPU Data Transfer</td><td class="p-3 font-mono bg-gray-50">Taichi ‚Üí NumPy</td></tr>
                                <tr class="border-b"><td class="p-3">Final Blit to Screen</td><td class="p-3 font-mono bg-gray-50">Pygame</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-xl font-bold text-center mb-6 text-[#ef5675]">The Critical GPU‚ÜíCPU Data Bridge</h3>
                    <p class="text-sm text-gray-600 text-center mb-8">The prototype's feasibility hinges on this two-step data pipeline, which moves the GPU-rendered frame into a Pygame surface for display.</p>
                    <div class="flex flex-col items-center space-y-4">
                        <div class="flowchart-node bg-red-100 text-red-800 border-red-500 w-full">1. Taichi `ti.field` (GPU Pixel Buffer)</div>
                        <div class="flowchart-arrow text-red-500"></div>
                        <div class="flowchart-node bg-yellow-100 text-yellow-800 border-yellow-500 w-full">2. `.to_numpy()` (Transfer to CPU)</div>
                        <div class="flowchart-arrow text-yellow-500"></div>
                        <div class="flowchart-node bg-gray-200 text-gray-800 border-gray-500 w-full">3. NumPy Array (CPU Memory)</div>
                        <div class="flowchart-arrow text-gray-500"></div>
                        <div class="flowchart-node bg-blue-100 text-blue-800 border-blue-500 w-full">4. `make_surface()` (Create Pygame Surface)</div>
                    </div>
                </div>
            </div>
        </section>

        <section id="roadmap" class="scroll-mt-24">
            <div class="text-center mb-12">
                <h2 class="text-3xl font-bold text-[#ff764a]">IV. Strategic Development Roadmap</h2>
                <p class="mt-2 text-gray-600 max-w-2xl mx-auto">A phased approach is recommended to manage complexity, de-risk ambitious goals, and deliver value incrementally across all three interface initiatives.</p>
            </div>
            <div class="bg-white rounded-lg shadow-md p-8">
                <div class="relative pl-8 border-l-4 border-gray-200">
                    <div class="timeline-item mb-12 border-[#003f5c]">
                        <h3 class="text-2xl font-bold text-[#003f5c]">Phase 1: Foundations & De-risking</h3>
                        <p class="text-gray-600 mt-2">Begin two concurrent workstreams. Implement the `ask-nix` TUI with Textual to provide immediate value. Simultaneously, build the Pygame/Taichi proof-of-concept to validate the long-term embodied AI architecture.</p>
                    </div>
                    <div class="timeline-item mb-12 border-[#7a5195]">
                        <h3 class="text-2xl font-bold text-[#7a5195]">Phase 2: Interactive Modalities</h3>
                        <p class="text-gray-600 mt-2">With foundations in place, shift focus to the voice pipeline. Build a PoC to evaluate orchestration patterns (`pipecat` vs. `Wyoming`), prioritizing the pattern that offers the best synergy with the headless engine's design.</p>
                    </div>
                    <div class="timeline-item border-[#ffa600]">
                        <h3 class="text-2xl font-bold text-[#ffa600]">Phase 3: Integration & Synergy</h3>
                        <p class="text-gray-600 mt-2">Once individual interfaces mature, explore integration opportunities. The TUI could become a control panel for the voice agent or embodied AI simulations, transforming separate tools into a cohesive ecosystem.</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="text-center p-8 mt-8 bg-gray-200">
        <p class="text-sm text-gray-600">Infographic generated based on the Technical Report on Python Libraries for Advanced User Interface Development.</p>
        <p class="text-xs text-gray-500 mt-2">Color Palette: Brilliant Blues. No SVG or Mermaid JS used in this artifact.</p>
    </footer>

    <script>
        const wrapText = (text, maxLength) => {
            if (typeof text !== 'string' || text.length <= maxLength) {
                return text;
            }
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            words.forEach(word => {
                if ((currentLine + ' ' + word).length > maxLength && currentLine.length > 0) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = currentLine ? currentLine + ' ' + word : word;
                }
            });
            if (currentLine) {
                lines.push(currentLine);
            }
            return lines;
        };

        const tooltipTitleCallback = (tooltipItems) => {
            const item = tooltipItems[0];
            let label = item.chart.data.labels[item.dataIndex];
            if (Array.isArray(label)) {
                return label.join(' ');
            } else {
                return label;
            }
        };

        const palette = {
            blue_dark: '#003f5c',
            blue_mid: '#374c80',
            purple: '#7a5195',
            magenta: '#bc5090',
            pink: '#ef5675',
            orange: '#ff764a',
            yellow: '#ffa600',
            bg_light: 'rgba(255, 166, 0, 0.2)',
            border_light: 'rgba(255, 166, 0, 1)'
        };

        const tuiData = {
            labels: ['Textual', 'curses', 'Pytermgui', 'ASCIIMATICS'],
            datasets: [{
                label: 'Styling Method',
                data: [4, 1, 2, 1],
                backgroundColor: palette.blue_mid,
                borderColor: palette.blue_dark,
                borderWidth: 1,
                categoryPercentage: 0.6,
                barPercentage: 0.7
            }, {
                label: 'Interactivity',
                data: [4, 1, 3, 2],
                backgroundColor: palette.purple,
                borderColor: palette.blue_dark,
                borderWidth: 1,
                categoryPercentage: 0.6,
                barPercentage: 0.7
            }, {
                label: 'Learning Curve',
                data: [2, 1, 3, 3],
                backgroundColor: palette.magenta,
                borderColor: palette.blue_dark,
                borderWidth: 1,
                categoryPercentage: 0.6,
                barPercentage: 0.7
            }]
        };

        const tuiComparisonCtx = document.getElementById('tuiComparisonChart').getContext('2d');
        new Chart(tuiComparisonCtx, {
            type: 'bar',
            data: tuiData,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                           title: tooltipTitleCallback
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Relative Capability Score (1=Low, 4=High)'
                        },
                        ticks: {
                            stepSize: 1
                        }
                    },
                    y: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });

        const paradigmData = {
            labels: ['Async Event Model', 'CSS-based Styling', 'Declarative UI'],
            datasets: [{
                data: [40, 35, 25],
                backgroundColor: [palette.blue_dark, palette.purple, palette.pink],
                hoverOffset: 4
            }]
        };

        const textualParadigmCtx = document.getElementById('textualParadigmChart').getContext('2d');
        new Chart(textualParadigmCtx, {
            type: 'doughnut',
            data: paradigmData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    tooltip: {
                        callbacks: {
                           title: tooltipTitleCallback
                        }
                    }
                }
            }
        });

        const latencyData = {
            labels: ['Voice Pipeline'],
            datasets: [{
                label: 'VAD',
                data: [30],
                backgroundColor: palette.blue_mid,
            }, {
                label: 'Whisper STT',
                data: [800],
                backgroundColor: palette.purple,
            }, {
                label: 'Engine Logic',
                data: [150],
                backgroundColor: palette.magenta,
            }, {
                label: 'Piper TTS (First Chunk)',
                data: [250],
                backgroundColor: palette.orange,
            }]
        };

        const latencyCtx = document.getElementById('latencyChart').getContext('2d');
        new Chart(latencyCtx, {
            type: 'bar',
            data: latencyData,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                           title: tooltipTitleCallback
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Typical Latency (milliseconds)'
                        }
                    },
                    y: {
                        stacked: true,
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    </script>
</body>
</html>
