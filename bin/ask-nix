#!/usr/bin/env python3
"""
üïâÔ∏è Main CLI for Nix for Humanity

This is the official CLI that uses the unified backend.
All the power, properly organized.
"""

import argparse
import asyncio
import logging
import os
import sys

# Configure logging to suppress info messages in normal operation
logging.basicConfig(
    level=logging.WARNING,  # Only show warnings and errors
    format="%(message)s",  # Simple format for user-facing messages
)

# Add the src directory to the Python path
sys.path.insert(
    0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src")
)

from nix_for_humanity.core.unified_backend import (
    Context,
    NixForHumanityBackend,
    get_backend,
)
from nix_for_humanity.plugins.config_generator import (
    ConfigGeneratorPlugin,
    SmartSearchPlugin,
)

# Import search command handler
try:
    from nix_for_humanity.cli.search_command import handle_search_in_query
    SEARCH_AVAILABLE = True
except ImportError:
    SEARCH_AVAILABLE = False

# Import pragmatic learning system
try:
    from nix_for_humanity.learning.pragmatic_learning import PragmaticLearningSystem

    LEARNING_AVAILABLE = True
except ImportError:
    LEARNING_AVAILABLE = False

# Import Tree-sitter commands (standalone to avoid Click dependency)
try:
    import importlib.util
    spec = importlib.util.spec_from_file_location(
        "tree_sitter_commands_standalone",
        os.path.join(
            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
            "src", "nix_for_humanity", "cli", "tree_sitter_commands_standalone.py"
        )
    )
    tree_sitter_module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(tree_sitter_module)
    TreeSitterCommands = tree_sitter_module.TreeSitterCommands
    TREE_SITTER_AVAILABLE = True
except Exception as e:
    TREE_SITTER_AVAILABLE = False
    # Log error for debugging (will only show with --debug)
    logging.debug(f"Tree-sitter module not available: {e}")


async def handle_tree_sitter_query(query: str, execute: bool):
    """Handle Tree-sitter related queries"""
    commands = TreeSitterCommands()
    query_lower = query.lower()
    
    # Analyze project
    if "analyze" in query_lower and ("project" in query_lower or "code" in query_lower):
        # Extract path from query (default to current directory)
        import re
        path_match = re.search(r'["\']([^"\']+)["\']', query)
        path = path_match.group(1) if path_match else "."
        
        result = commands.analyze_project(path)
        if result["success"]:
            print(result["message"])
            return 0
        else:
            print(f"Error: {result.get('error', 'Analysis failed')}")
            return 1
    
    # Migrate shell script
    elif "migrate" in query_lower or "convert" in query_lower:
        import re
        from pathlib import Path
        # Look for .sh file in query
        script_match = re.search(r'(\S+\.sh)', query)
        if script_match:
            script = script_match.group(1)
            # Check if file exists (handle both relative and absolute paths)
            if not Path(script).exists():
                # Try in /tmp if it's a temp file
                if script.startswith("tmp"):
                    script = f"/tmp/{script}"
            
            if Path(script).exists():
                result = commands.migrate_script(script)
                if result["success"]:
                    print(result["message"])
                    return 0
                else:
                    print(f"Error: {result.get('message', 'Migration failed')}")
                    return 1
            else:
                print(f"Error: Script file '{script}' not found")
                return 1
        else:
            print("Please specify a shell script to migrate (e.g., 'migrate setup.sh')")
            return 1
    
    # Suggest packages
    elif "suggest" in query_lower or "package for" in query_lower:
        # Extract description after "for" or "suggest"
        if "package for" in query_lower:
            description = query_lower.split("package for")[-1].strip()
        else:
            description = query_lower.replace("suggest packages", "").replace("suggest", "").strip()
        
        if description:
            result = commands.suggest_packages(description)
            if result["success"]:
                print(result["message"])
                if result["suggestions"]:
                    print("\nüí° Suggested packages:")
                    for pkg in result["suggestions"]:
                        print(f"  - {pkg}")
                return 0
            else:
                print(f"Error: {result.get('error')}")
                return 1
    
    # Generate config
    elif "generate" in query_lower and "config" in query_lower:
        template = "minimal"  # Default
        if "desktop" in query_lower:
            template = "desktop"
        elif "development" in query_lower or "dev" in query_lower:
            template = "development"
        
        result = commands.generate_config(template)
        if result["success"]:
            print(result["message"])
            print("\n" + result["config"][:500] + "...")
            return 0
        else:
            print(f"Error: {result.get('error')}")
            return 1
    
    # If we couldn't handle it, fall back to regular processing
    return None


def setup_backend(dry_run=True):
    """Setup the backend with all plugins"""
    # Let backend use config manager, but override dry_run if needed
    backend = get_backend()
    if dry_run != backend.config.get("dry_run", True):
        backend.config["dry_run"] = dry_run

    # Register plugins
    backend.register_plugin(ConfigGeneratorPlugin())
    backend.register_plugin(SmartSearchPlugin())

    return backend


async def execute_query(
    query: str, execute: bool = False, enable_learning: bool = True
):
    """Execute a natural language query with optional learning"""
    # Handle help queries specially
    if query.lower() in ["help", "help me", "what can you do", "how do i use this"]:
        show_help()
        return 0
    
    # Check for search queries (high priority)
    if SEARCH_AVAILABLE and handle_search_in_query(query):
        return 0
    
    # Check for Tree-sitter related queries
    if TREE_SITTER_AVAILABLE:
        tree_keywords = [
            "analyze project", "analyze code", "scan project", "analyze my",
            "migrate", "convert script", "shell to nix",
            "suggest package", "package for",
            "generate config", "config template"
        ]
        
        query_lower = query.lower()
        for keyword in tree_keywords:
            if keyword in query_lower:
                logging.info(f"Tree-sitter handling query: {query}")
                result = await handle_tree_sitter_query(query, execute)
                if result is not None:
                    return result
                # If Tree-sitter couldn't handle it, continue with regular processing
                break
    else:
        logging.debug("Tree-sitter not available")

    # Initialize learning system if available and enabled
    learning = None
    if LEARNING_AVAILABLE and enable_learning:
        try:
            learning = PragmaticLearningSystem("cli_user")

            # Check for learned aliases
            alias_suggestion = learning.suggest_alias(query)
            if alias_suggestion:
                print(f"üí° {alias_suggestion}")
        except Exception:
            pass  # Learning is optional, don't fail on errors

    # Determine if this might be a long operation
    long_operations = ["install", "update", "rebuild", "search", "generate", "build"]
    is_long = any(op in query.lower() for op in long_operations)

    # Show progress for long operations if in a terminal
    spinner = None
    if is_long and sys.stdout.isatty():
        try:
            from nix_for_humanity.ui.progress import Spinner

            spinner = Spinner("Processing your request")
            spinner.start()
        except ImportError:
            pass  # Progress indicator not available

    try:
        backend = setup_backend(dry_run=not execute)
        await backend.initialize()

        context = Context(user_id="cli_user")
        result = await backend.execute(query, context)

        # Track learning if enabled
        if learning:
            try:
                learning.observe_command(query, result.success, result.error)

                # Suggest next command if successful
                if result.success:
                    next_suggestion = learning.suggest_next_command(query)
                    if next_suggestion:
                        print(f"\nüîÆ {next_suggestion}")

                # Suggest error fix if failed
                elif result.error:
                    error_fix = learning.suggest_error_fix(result.error)
                    if error_fix:
                        print(f"\nüí° {error_fix}")
            except Exception:
                pass  # Learning failures shouldn't break the command

        # Stop spinner before displaying result
        if spinner:
            if result.success:
                spinner.stop("‚úì Complete")
            else:
                spinner.stop("‚úó Failed")

        # Display result
        if result.success:
            print(result.output)
        else:
            print(f"Error: {result.error}")
            if result.suggestions:
                print("\nSuggestions:")
                for suggestion in result.suggestions:
                    print(f"  ‚Ä¢ {suggestion}")

        await backend.cleanup()
        return 0 if result.success else 1

    except Exception as e:
        if spinner:
            spinner.stop("‚úó Error")
        raise


async def interactive_mode():
    """Interactive REPL mode"""
    print("üïâÔ∏è Nix for Humanity - Interactive Mode")
    print("Enter natural language commands. Type 'exit' to leave.")
    print("Prefix with '!' to execute for real (not dry-run).")
    print()

    backend = setup_backend(dry_run=True)
    await backend.initialize()
    context = Context(user_id="cli_user")

    while True:
        try:
            query = input("nix> ").strip()

            if query.lower() in ["exit", "quit"]:
                break

            if not query:
                continue

            # Check for execution prefix
            if query.startswith("!"):
                query = query[1:].strip()
                backend.config["dry_run"] = False
            else:
                backend.config["dry_run"] = True

            result = await backend.execute(query, context)

            if result.output:
                print(result.output)
            if result.error:
                print(f"Error: {result.error}")

        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Error: {e}")

    await backend.cleanup()


def show_help():
    """Show comprehensive help information"""
    help_text = """
üïâÔ∏è Nix for Humanity - Natural Language NixOS Interface

USAGE:
    ask-nix [OPTIONS] <QUERY>
    ask-nix --interactive

EXAMPLES:
    # Install a package (dry-run by default)
    ask-nix "install firefox"

    # Execute for real
    ask-nix --execute "install firefox"

    # Search for packages
    ask-nix "search for markdown editor"

    # Generate configurations
    ask-nix "web server with nginx and postgresql"

    # Development environments
    ask-nix "development environment with python and rust"

    # Interactive mode
    ask-nix --interactive

FEATURES:
    ‚Ä¢ Natural language understanding
    ‚Ä¢ Smart package discovery
    ‚Ä¢ Configuration generation
    ‚Ä¢ Safe dry-run by default
    ‚Ä¢ 10x-1500x faster with native API

TIPS:
    ‚Ä¢ Use simple, natural language
    ‚Ä¢ Preview operations with dry-run
    ‚Ä¢ Use --execute only when ready
    ‚Ä¢ Try --debug for troubleshooting

For more information, visit: https://github.com/Luminous-Dynamics/nix-for-humanity
"""
    print(help_text)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Natural language interface to NixOS",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Use 'ask-nix --help-full' for comprehensive help",
    )
    parser.add_argument("query", nargs="*", help="Natural language query")
    parser.add_argument(
        "--execute", "-e", action="store_true", help="Execute for real (not dry-run)"
    )
    parser.add_argument(
        "--interactive", "-i", action="store_true", help="Interactive mode"
    )
    parser.add_argument(
        "--debug", "-d", action="store_true", help="Enable debug logging"
    )
    parser.add_argument(
        "--log-level",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default=None,
        help="Set logging level",
    )
    parser.add_argument("--log-file", type=str, help="Log to file instead of console")
    parser.add_argument(
        "--help-full", action="store_true", help="Show comprehensive help with examples"
    )
    parser.add_argument(
        "--no-learning",
        action="store_true",
        help="Disable learning and personalization",
    )
    parser.add_argument(
        "--show-learning",
        action="store_true",
        help="Show what the system has learned about you",
    )
    parser.add_argument(
        "--delete-learning-data",
        action="store_true",
        help="Delete all learned data and reset",
    )

    args = parser.parse_args()

    # Configure logging using our logging config system
    from nix_for_humanity.core.logging_config import setup_logging

    if args.debug:
        setup_logging(debug=True)
    elif args.log_level:
        setup_logging(level=args.log_level)
    else:
        # Default: only warnings and errors to console
        setup_logging(level="WARNING")

    # Add file handler if specified
    if args.log_file:
        import logging.handlers

        from nix_for_humanity.core.logging_config import get_logging_config

        file_handler = logging.handlers.RotatingFileHandler(
            args.log_file, maxBytes=10 * 1024 * 1024, backupCount=3  # 10MB
        )
        file_handler.setFormatter(
            logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        )
        get_logging_config().add_handler("", file_handler)

    # Show comprehensive help if requested
    if args.help_full:
        show_help()
        return 0

    # Handle learning management
    if args.show_learning:
        if LEARNING_AVAILABLE:
            learning = PragmaticLearningSystem("cli_user")
            print(learning.export_learnings())
        else:
            print("Learning system not available")
        return 0

    if args.delete_learning_data:
        if LEARNING_AVAILABLE:
            learning = PragmaticLearningSystem("cli_user")
            print(learning.delete_all_data())
        else:
            print("Learning system not available")
        return 0

    if args.interactive:
        return asyncio.run(interactive_mode())
    elif args.query:
        query = " ".join(args.query)
        enable_learning = not args.no_learning
        return asyncio.run(execute_query(query, args.execute, enable_learning))
    else:
        parser.print_help()
        return 0


if __name__ == "__main__":
    sys.exit(main())
