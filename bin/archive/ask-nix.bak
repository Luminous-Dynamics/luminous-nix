#!/usr/bin/env python3
"""
Modern NixOS Assistant - Uses current best practices with progress indicators
Includes: nix profile, Home Manager, deprecation warnings, and better UX
"""

import sys
import subprocess
import time
import threading
from pathlib import Path
import os
import json
import shutil
import tempfile
import importlib.util
from typing import Dict

# Add scripts directory to path
script_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'scripts'))
sys.path.insert(0, script_dir)

# Import our modern knowledge engine
import importlib.util
spec = importlib.util.spec_from_file_location("nix_knowledge_engine_modern", 
    os.path.join(script_dir, "nix-knowledge-engine-modern.py"))
nix_knowledge_engine_modern = importlib.util.module_from_spec(spec)
spec.loader.exec_module(nix_knowledge_engine_modern)
ModernNixOSKnowledgeEngine = nix_knowledge_engine_modern.ModernNixOSKnowledgeEngine

class ProgressSpinner:
    """Simple progress spinner for long operations"""
    def __init__(self, message="Processing", estimated_time=None):
        self.message = message
        self.estimated_time = estimated_time
        self.running = False
        self.thread = None
        self.spinner_chars = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
        self.current = 0
        
    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self._spin)
        self.thread.start()
        
    def _spin(self):
        while self.running:
            time_info = f" (Est: {self.estimated_time})" if self.estimated_time else ""
            sys.stdout.write(f'\r{self.spinner_chars[self.current]} {self.message}{time_info}')
            sys.stdout.flush()
            self.current = (self.current + 1) % len(self.spinner_chars)
            time.sleep(0.1)
            
    def stop(self, final_message=None):
        self.running = False
        if self.thread:
            self.thread.join()
        sys.stdout.write('\r' + ' ' * 80 + '\r')  # Clear line
        if final_message:
            print(final_message)
        sys.stdout.flush()

class ModernNixAssistant:
    def __init__(self):
        self.knowledge = ModernNixOSKnowledgeEngine()
        self.personality = 'friendly'  # Can be: minimal, friendly, encouraging, technical
        self.show_progress = True
        self.dry_run = False  # Execute by default (Phase 1: Make It Real)
        self.show_intent = False
        self.retry_count = 3  # For reliability
        
    def enhance_response(self, response: str, query: str, personality: str) -> str:
        """Add personality to the factual response"""
        
        if personality == 'minimal':
            # Just return the facts
            return response
            
        elif personality == 'friendly':
            # Add warm greeting and closing
            enhanced = f"Hi there! {response}\n\nLet me know if you need any clarification! üòä"
            return enhanced
            
        elif personality == 'encouraging':
            # Add encouragement
            enhanced = f"Great question! {response}\n\nYou're doing awesome learning NixOS! Keep it up! üåü"
            
            # Add extra tips for beginners
            if 'without sudo' in query.lower():
                enhanced += "\n\nüí° Pro tip: You're already thinking like a NixOS pro by avoiding sudo!"
            return enhanced
            
        elif personality == 'technical':
            # Add technical depth
            enhanced = f"{response}\n\nNote: This follows NixOS's declarative configuration paradigm."
            
            # Add technical details
            if 'nix profile' in response:
                enhanced += "\n\nTechnical note: nix profile uses the new Nix 2.0 CLI with improved UX."
            return enhanced
            
        return response
    
    def execute_with_bridge(self, intent: Dict, operation: str = "command") -> tuple:
        """Execute command using the execution bridge for safer operation"""
        import json
        
        # Get progress info for this operation
        progress_info = self.knowledge.get_progress_message(operation)
        
        # Prepare intent for bridge
        intent_json = json.dumps(intent)
        bridge_path = os.path.join(os.path.dirname(__file__), 'execution-bridge.js')
        
        # Start progress spinner
        spinner = ProgressSpinner(progress_info['message'], progress_info['estimated_time'])
        if self.show_progress:
            spinner.start()
        
        try:
            # Execute via bridge
            result = subprocess.run(
                ['node', bridge_path, intent_json],
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            if self.show_progress:
                spinner.stop()
            
            # Parse bridge response
            if result.stdout:
                try:
                    response = json.loads(result.stdout)
                    
                    # Check for educational error information
                    if not response.get('success', False) and response.get('suggestions'):
                        # Format educational error message
                        error_msg = f"\n‚ùå {response.get('error', 'Operation failed')}\n"
                        
                        if response.get('suggestions'):
                            error_msg += "\nüí° Suggestions:\n"
                            for suggestion in response['suggestions']:
                                error_msg += f"   ‚Ä¢ {suggestion}\n"
                        
                        if response.get('learnMore'):
                            error_msg += f"\nüìö Learn more: {response['learnMore']}\n"
                        
                        return False, response.get('output', ''), error_msg
                    
                    return response.get('success', False), response.get('output', ''), response.get('error', '')
                except json.JSONDecodeError:
                    return False, '', f"Invalid bridge response: {result.stdout}"
            else:
                return False, '', result.stderr or "Bridge execution failed"
                
        except subprocess.TimeoutExpired:
            if self.show_progress:
                spinner.stop()
            return False, '', "Command timed out. This might be normal for large operations."
        except Exception as e:
            if self.show_progress:
                spinner.stop()
            return False, '', str(e)
    
    def execute_with_progress(self, command: str, operation: str = "command") -> tuple:
        """Execute command with progress indicator and retry logic"""
        # Get progress info for this operation
        progress_info = self.knowledge.get_progress_message(operation)
        
        # Start progress spinner
        spinner = ProgressSpinner(progress_info['message'], progress_info['estimated_time'])
        if self.show_progress:
            spinner.start()
        
        success = False
        output = ""
        error = ""
        
        for attempt in range(self.retry_count):
            try:
                # Execute command
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=300  # 5 minute timeout
                )
                
                if result.returncode == 0:
                    success = True
                    output = result.stdout
                    break
                else:
                    error = result.stderr
                    if attempt < self.retry_count - 1:
                        time.sleep(2)  # Wait before retry
                        
            except subprocess.TimeoutExpired:
                error = "Command timed out. This might be normal for large operations."
                if attempt < self.retry_count - 1:
                    spinner.message = f"{progress_info['message']} (Retry {attempt + 1})"
            except Exception as e:
                error = str(e)
                break
        
        # Stop spinner
        if self.show_progress:
            if success:
                spinner.stop(f"‚úÖ {operation.capitalize()} completed successfully!")
            else:
                spinner.stop(f"‚ùå {operation.capitalize()} failed")
        
        return success, output, error
    
    def check_home_manager_installed(self) -> bool:
        """Check if Home Manager is installed"""
        try:
            result = subprocess.run(
                "home-manager --version",
                shell=True,
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def validate_package_name(self, package: str) -> tuple:
        """Validate if package exists in nixpkgs"""
        if not package:
            return False, "No package name provided"
            
        # Skip validation if using bridge - let nix handle it
        if hasattr(self, 'use_bridge') and self.use_bridge:
            return True, "Package validation deferred to nix"
            
        # Quick validation with nix search
        spinner = ProgressSpinner("üîç Validating package name", "2-5 seconds")
        if self.show_progress:
            spinner.start()
            
        try:
            # Search more broadly - just check if search returns any results
            result = subprocess.run(
                f"nix search nixpkgs {package} --json",
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if self.show_progress:
                spinner.stop()
                
            if result.returncode == 0 and result.stdout.strip() != "{}":
                # Parse JSON to find exact match or close match
                try:
                    import json
                    packages = json.loads(result.stdout)
                    # Look for exact match or package containing the search term
                    for pkg_path, pkg_info in packages.items():
                        pkg_name = pkg_path.split('.')[-1]
                        if pkg_name.lower() == package.lower():
                            return True, f"Package '{package}' found"
                        elif package.lower() in pkg_name.lower():
                            return True, f"Package '{package}' found (as '{pkg_name}')"
                    # If we found results but no exact match, still allow it
                    if packages:
                        return True, f"Package '{package}' may be available"
                except:
                    pass
                    
                return True, "Package search returned results"
            else:
                # Try common aliases
                if package in self.knowledge.package_aliases:
                    actual_package = self.knowledge.package_aliases[package]
                    return True, f"Package '{package}' maps to '{actual_package}'"
                    
                # For common packages that might have different names, be lenient
                common_packages = ['tree', 'htop', 'git', 'vim', 'emacs', 'firefox', 'chrome']
                if package.lower() in common_packages:
                    return True, f"Package '{package}' is likely available"
                    
                return False, f"Package '{package}' not found in nixpkgs"
        except:
            if self.show_progress:
                spinner.stop()
            # On error, be permissive rather than restrictive
            return True, "Could not validate package, proceeding anyway"
    
    def confirm_action(self, action: str, details: str) -> bool:
        """Ask for confirmation before destructive actions"""
        print(f"\n‚ö†Ô∏è  Confirm {action}:")
        print(f"   {details}")
        print()
        response = input("Proceed? [y/N]: ").strip().lower()
        return response in ['y', 'yes']
    
    def execute_list(self):
        """Execute list packages command with formatting"""
        print("üì¶ Listing installed packages...")
        
        command = "nix profile list"
        
        # Execute the command
        success, output, error = self.execute_with_progress(command, "list")
        
        if success:
            if output.strip():
                print("\nüìã Installed packages:")
                print("-" * 50)
                
                # Parse and format the output (new nix profile list format)
                lines = output.strip().split('\n')
                package_num = 1
                current_package = None
                
                for line in lines:
                    line = line.strip()
                    # Look for package names (bold in terminal output)
                    if line.startswith('Name:'):
                        # Extract package name (remove ANSI codes)
                        import re
                        package_name = re.sub(r'\x1b\[[0-9;]*m', '', line)
                        package_name = package_name.replace('Name:', '').strip()
                        if package_name and package_name != 'home-manager-path':
                            print(f"  {package_num}. {package_name}")
                            package_num += 1
                        
                print("\nüí° Tip: Use 'ask-nix \"remove package-name\"' to remove a package")
            else:
                print("\nüìã No packages installed in current profile")
                print("\nüí° Install packages with: ask-nix \"install package-name\"")
        else:
            print(f"\n‚ùå Failed to list packages: {error}")
    
    def execute_remove(self, package: str):
        """Execute package removal with confirmation"""
        # First list packages in JSON format to get indices
        result = subprocess.run(
            "nix profile list --json",
            shell=True,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"‚ùå Failed to list packages: {result.stderr}")
            return
            
        # Parse JSON to find the package
        package_index = None
        package_name_found = None
        
        try:
            profiles = json.loads(result.stdout)
            # profiles is a dict where keys are indices
            for index, info in profiles.items():
                # Check various fields for the package name
                if 'storePaths' in info and info['storePaths']:
                    # Extract package name from store path
                    store_path = info['storePaths'][0]
                    # Format: /nix/store/hash-packagename-version
                    parts = store_path.split('-', 2)
                    if len(parts) >= 3:
                        pkg_name = parts[1]
                        if package.lower() in pkg_name.lower():
                            package_index = index
                            package_name_found = pkg_name
                            break
                
                # Also check flakeAttribute if available
                if 'flakeAttribute' in info:
                    attr = info['flakeAttribute']
                    if package.lower() in attr.lower():
                        package_index = index
                        package_name_found = attr.split('.')[-1]
                        break
        except json.JSONDecodeError:
            print("‚ùå Failed to parse package list")
            return
        
        if not package_index:
            print(f"\n‚ö†Ô∏è  Package '{package}' not found in profile")
            print("\nüí° Use 'ask-nix \"list packages\"' to see installed packages")
            return
        
        # Confirm removal
        if not self.dry_run and not hasattr(self, 'skip_confirmation'):
            if not self.confirm_action("removal", f"Remove package '{package}' (index {package_index})"):
                print("\n‚ùå Removal cancelled.")
                return
        
        print(f"\nüóëÔ∏è  Removing {package}...")
        
        command = f"nix profile remove {package_index}"
        if self.dry_run:
            command += " --dry-run"
            print(f"\nüîç Dry run mode - showing what would happen:")
        
        # Execute the command
        success, output, error = self.execute_with_progress(command, "remove")
        
        if success:
            if self.dry_run:
                print("\n‚úÖ Dry run successful! To actually remove, run:")
                print(f"   {command.replace(' --dry-run', '')}")
            else:
                print(f"\n‚úÖ Successfully removed {package}!")
                print("\nüí° The package has been removed from your profile.")
        else:
            print(f"\n‚ùå Removal failed: {error}")
            print("\nüí° Troubleshooting tips:")
            print("   - Check if the package is installed")
            print("   - Use 'ask-nix \"list packages\"' to verify")
    
    def execute_update(self, prefer_no_sudo: bool = False):
        """Execute system update with appropriate method"""
        if prefer_no_sudo or not self._is_nixos():
            # Use Home Manager if available
            if self.check_home_manager_installed():
                print("üîÑ Updating Home Manager packages...")
                command = "home-manager switch"
                operation = "Home Manager update"
            else:
                print("üîÑ Updating nix profile packages...")
                command = "nix profile upgrade '.*'"
                operation = "profile update"
        else:
            # Full system update
            print("üîÑ Updating NixOS system configuration...")
            
            # Confirm system update
            if not self.dry_run and not hasattr(self, 'skip_confirmation'):
                if not self.confirm_action("system update", "Update entire NixOS system (requires sudo)"):
                    print("\n‚ùå Update cancelled.")
                    return
            
            # Update channels first
            print("\nüì° Updating channels...")
            channel_success, _, channel_error = self.execute_with_progress(
                "sudo nix-channel --update", 
                "channel update"
            )
            
            if not channel_success:
                print(f"‚ö†Ô∏è  Channel update failed: {channel_error}")
                print("Continuing with system rebuild anyway...")
            
            command = "sudo nixos-rebuild switch"
            operation = "system rebuild"
            
            if self.dry_run:
                command += " --dry-run"
                print(f"\nüîç Dry run mode - showing what would happen:")
        
        # Execute the update
        success, output, error = self.execute_with_progress(command, operation)
        
        if success:
            if self.dry_run:
                print("\n‚úÖ Dry run successful! To actually update, run:")
                print(f"   {command.replace(' --dry-run', '')}")
            else:
                print(f"\n‚úÖ Successfully updated!")
                if "nixos-rebuild" in command:
                    print("\nüéâ Your NixOS system is now up to date!")
                    print("üí° Tip: Some changes may require a reboot to take effect.")
                else:
                    print("\nüéâ Your packages are now up to date!")
        else:
            print(f"\n‚ùå Update failed: {error}")
            print("\nüí° Troubleshooting tips:")
            print("   - Check your internet connection")
            print("   - Try running with --show-trace for more details")
            if "nixos-rebuild" in command:
                print("   - Check for syntax errors in /etc/nixos/configuration.nix")
    
    def _is_nixos(self) -> bool:
        """Check if running on NixOS"""
        try:
            return Path("/etc/nixos/configuration.nix").exists()
        except:
            return False
    
    def execute_install(self, package: str, method: str = 'nix-profile'):
        """Execute package installation with proper error handling"""
        # Validate package first
        valid, message = self.validate_package_name(package)
        if not valid:
            print(f"\n‚ö†Ô∏è  {message}")
            print("\nüí° Try searching for the package:")
            print(f"   nix search nixpkgs {package}")
            return
        
        # Confirm installation unless --yes flag is used
        if not self.dry_run and not hasattr(self, 'skip_confirmation'):
            if not self.confirm_action("installation", f"Install package '{package}'"):
                print("\n‚ùå Installation cancelled.")
                return
        
        print(f"\nüì¶ Installing {package} using {method}...")
        
        if method == 'nix-profile':
            command = f"nix profile install nixpkgs#{package}"
            if self.dry_run:
                command += " --dry-run"
                print(f"\nüîç Dry run mode - showing what would happen:")
                
        elif method == 'home-manager':
            if not self.check_home_manager_installed():
                print("\n‚ö†Ô∏è  Home Manager is not installed.")
                print("\nüí° To install Home Manager, run:")
                print("   nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager")
                print("   nix-channel --update")
                print("   nix-shell '<home-manager>' -A install")
                return
                
            print("\nüìù To install with Home Manager:")
            print(f"1. Edit ~/.config/home-manager/home.nix")
            print(f"2. Add to home.packages: {package}")
            print(f"3. Run: home-manager switch")
            return
            
        # Execute the command - use bridge if available
        if hasattr(self, 'use_bridge') and self.use_bridge:
            intent = {
                'action': 'install_package',
                'package': package
            }
            success, output, error = self.execute_with_bridge(intent, "install")
        else:
            success, output, error = self.execute_with_progress(command, "install")
        
        if success:
            if self.dry_run:
                print("\n‚úÖ Dry run successful! To actually install, run:")
                print(f"   {command.replace(' --dry-run', '')}")
            else:
                print(f"\n‚úÖ Successfully installed {package}!")
                print("\nüí° The package is now available in your PATH.")
        else:
            # If error is already formatted (from bridge), just print it
            if hasattr(self, 'use_bridge') and self.use_bridge and '\nüí° Suggestions:' in error:
                print(error)
            else:
                print(f"\n‚ùå Installation failed: {error}")
                print("\nüí° Troubleshooting tips:")
                print("   - Check if the package name is correct")
                print("   - Try updating your channels: nix-channel --update")
                print("   - Check your internet connection")
    
    def answer(self, query: str):
        """Process query through modern knowledge engine"""
        
        # Step 1: Extract intent
        intent = self.knowledge.extract_intent(query)
        
        if self.show_intent:
            print(f"\nüéØ Intent detected: {intent['action']}")
            if intent.get('package'):
                print(f"üì¶ Package: {intent['package']}")
            if intent.get('prefer_no_sudo'):
                print(f"üîì No sudo preference: Yes")
            print()
        
        # Step 2: Get accurate solution
        solution = self.knowledge.get_solution(intent)
        
        # Step 3: Format response
        response = self.knowledge.format_response(intent, solution)
        
        # Step 4: Add personality
        final_response = self.enhance_response(response, query, self.personality)
        
        print(final_response)
        
        # Step 5: Note about execution (removed since we now auto-execute)
        
    def set_personality(self, style: str):
        """Change response personality"""
        if style in ['minimal', 'friendly', 'encouraging', 'technical']:
            self.personality = style

def print_usage():
    """Print usage information"""
    print("Usage: ask-nix-modern [OPTIONS] 'your question'")
    print("\nExamples:")
    print("  ask-nix-modern 'How do I install Firefox?'")
    print("  ask-nix-modern 'Install docker without sudo'")
    print("  ask-nix-modern 'Update my system'")
    print("\nOptions:")
    print("  --minimal         Just the facts")
    print("  --friendly        Warm and helpful (default)")
    print("  --encouraging     Supportive for beginners")
    print("  --technical       Detailed explanations")
    print("  --dry-run         Test without executing (safety mode)")
    print("  --yes             Skip confirmation prompts")
    print("  --show-intent     Show intent detection")
    print("  --no-progress     Disable progress indicators")
    print("  --execute         Use execution bridge (safer)")
    print("  --bridge          Alias for --execute")
    print("\nModern features:")
    print("  ‚úÖ Uses nix profile instead of deprecated nix-env")
    print("  ‚úÖ Suggests Home Manager for sudo-free operations")
    print("  ‚úÖ Shows progress for long operations")
    print("  ‚úÖ Validates packages before installing")
    print("  ‚úÖ Retries failed operations automatically")

def main():
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    
    assistant = ModernNixAssistant()
    
    # Parse arguments
    args = sys.argv[1:]
    execute_mode = False
    
    while args and args[0].startswith('--'):
        flag = args.pop(0)
        
        if flag in ['--minimal', '--friendly', '--encouraging', '--technical']:
            assistant.set_personality(flag[2:])
        elif flag == '--dry-run':
            assistant.dry_run = True
        elif flag == '--yes':
            assistant.skip_confirmation = True
        elif flag == '--show-intent':
            assistant.show_intent = True
        elif flag == '--no-progress':
            assistant.show_progress = False
        elif flag in ['--execute', '--bridge']:
            assistant.use_bridge = True
        elif flag == '--help':
            print_usage()
            sys.exit(0)
        else:
            print(f"Unknown option: {flag}")
            print_usage()
            sys.exit(1)
    
    if not args:
        print("Error: No question provided")
        sys.exit(1)
        
    query = ' '.join(args)
    
    # Process the query
    assistant.answer(query)
    
    # Auto-execute install commands (unless in dry-run mode)
    intent = assistant.knowledge.extract_intent(query)
    if intent['action'] == 'install_package' and intent.get('package'):
        print()
        if assistant.dry_run:
            print("üîç Running in dry-run mode (use without --dry-run to execute)")
        else:
            # Determine method based on sudo preference
            if intent.get('prefer_no_sudo'):
                if assistant.check_home_manager_installed():
                    method = 'home-manager'
                else:
                    method = 'nix-profile'
            else:
                method = 'nix-profile'
                
            assistant.execute_install(intent['package'], method)
    
    # Auto-execute list commands
    elif intent['action'] == 'list_packages':
        print()
        assistant.execute_list()
    
    # Auto-execute remove commands
    elif intent['action'] == 'remove_package' and intent.get('package'):
        print()
        if assistant.dry_run:
            print("üîç Running in dry-run mode (use without --dry-run to execute)")
        else:
            # Use bridge if available
            if hasattr(assistant, 'use_bridge') and assistant.use_bridge:
                intent_for_bridge = {
                    'action': 'remove_package',
                    'package': intent['package']
                }
                success, output, error = assistant.execute_with_bridge(intent_for_bridge, "remove")
                if success:
                    print(f"\n‚úÖ Successfully removed {intent['package']}!")
                else:
                    # Error is already formatted with suggestions
                    print(error)
            else:
                assistant.execute_remove(intent['package'])
    
    # Auto-execute search commands
    elif intent['action'] == 'search_package':
        print()
        if hasattr(assistant, 'use_bridge') and assistant.use_bridge:
            intent_for_bridge = {
                'action': 'search_package',
                'query': query,
                'package': intent.get('package')
            }
            success, output, error = assistant.execute_with_bridge(intent_for_bridge, "search")
            if not success:
                print(f"\n‚ùå Search failed: {error}")
        else:
            # Fallback to showing search command
            package = intent.get('package', query.replace('search', '').strip())
            print(f"\nüîç To search for '{package}', run:")
            print(f"   nix search nixpkgs {package}")
    
    # Auto-execute update commands
    elif intent['action'] in ['update_system', 'update_system_sudo']:
        print()
        if assistant.dry_run:
            print("üîç Running in dry-run mode (use without --dry-run to execute)")
        else:
            # Use bridge if available
            if hasattr(assistant, 'use_bridge') and assistant.use_bridge:
                intent_for_bridge = {
                    'action': 'update_system',
                    'query': query,
                    'systemUpdate': intent['action'] == 'update_system_sudo'
                }
                success, output, error = assistant.execute_with_bridge(intent_for_bridge, "update")
                if success:
                    print(f"\n‚úÖ Update completed successfully!")
                else:
                    print(f"\n‚ùå Update failed: {error}")
            else:
                assistant.execute_update(intent.get('prefer_no_sudo', False))

if __name__ == "__main__":
    main()