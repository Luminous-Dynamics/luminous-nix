#!/usr/bin/env python3
"""
nix-do - Actually EXECUTE NixOS commands from natural language
Phase 0: Make it work, make it safe, make it simple
"""

import os
import subprocess
import sys
from pathlib import Path

# Add backend/scripts to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "scripts"))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "backend", "python"))

from nix_knowledge_engine import NixOSKnowledgeEngine


class NixDoExecutor:
    """Actually executes NixOS commands - no more just talking about it\!"""

    def __init__(self, dry_run=False):
        self.knowledge = NixOSKnowledgeEngine()
        self.dry_run = dry_run

    def execute(self, query: str) -> dict:
        """Process natural language and EXECUTE the command"""

        # Extract intent
        intent = self.knowledge.extract_intent(query)
        print(f"üéØ Intent: {intent['action']}")

        # Handle different actions
        if intent["action"] == "install_package":
            return self.install_package(intent.get("package"))
        elif intent["action"] == "update_system":
            return self.update_system()
        elif intent["action"] == "search_package":
            return self.search_package(intent.get("query"))
        else:
            return {
                "success": False,
                "message": f"I understand you want to {intent['action']}, but I can't execute that yet.",
            }

    def install_package(self, package: str) -> dict:
        """Actually install a package"""
        if not package:
            return {"success": False, "message": "No package specified"}

        # Map common names to actual packages
        package_map = self.knowledge.package_aliases
        actual_package = package_map.get(package, package)

        print(f"üì¶ Installing {actual_package}...")

        # Build the command
        cmd = ["nix-env", "-iA", f"nixos.{actual_package}"]

        if self.dry_run:
            print(f"üèÉ Would run: {' '.join(cmd)}")
            return {
                "success": True,
                "message": f"Would install {actual_package}",
                "command": cmd,
            }

        # ACTUALLY EXECUTE
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                print(f"‚úÖ Successfully installed {actual_package}\!")
                return {
                    "success": True,
                    "message": f"Installed {actual_package}",
                    "output": result.stdout,
                }
            else:
                # Try with --dry-run first to see what would happen
                dry_cmd = cmd + ["--dry-run"]
                dry_result = subprocess.run(dry_cmd, capture_output=True, text=True)

                return {
                    "success": False,
                    "message": f"Failed to install {actual_package}",
                    "error": result.stderr,
                    "dry_run_output": dry_result.stdout,
                }

        except Exception as e:
            return {"success": False, "message": f"Error executing command: {str(e)}"}

    def update_system(self) -> dict:
        """Actually update the system"""
        print("üîÑ Updating system...")

        if self.dry_run:
            print("üèÉ Would run: sudo nixos-rebuild switch")
            return {"success": True, "message": "Would update system"}

        # For safety, we'll use --dry-run for system updates in Phase 0
        cmd = ["sudo", "nixos-rebuild", "switch", "--dry-run"]

        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            return {
                "success": True,
                "message": "System update preview (use --live to actually update)",
                "output": result.stdout,
            }
        except Exception as e:
            return {"success": False, "message": f"Error: {str(e)}"}

    def search_package(self, query: str) -> dict:
        """Actually search for packages"""
        print(f"üîç Searching for packages...")

        # Use nix search
        cmd = ["nix", "search", "nixpkgs", query]

        try:
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                return {
                    "success": True,
                    "message": f'Search results for "{query}"',
                    "output": result.stdout,
                }
            else:
                return {
                    "success": False,
                    "message": "Search failed",
                    "error": result.stderr,
                }
        except Exception as e:
            return {"success": False, "message": f"Error: {str(e)}"}


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: nix-do 'command'")
        print("\nExamples:")
        print("  nix-do 'install firefox'        # Actually installs\!")
        print("  nix-do 'search browser'         # Actually searches\!")
        print("  nix-do 'update system'          # Shows what would update")
        print("\nOptions:")
        print("  --dry-run    Show what would be done")
        print("  --live       Actually execute (default)")
        sys.exit(1)

    # Parse arguments
    dry_run = False
    args = sys.argv[1:]

    if "--dry-run" in args:
        dry_run = True
        args.remove("--dry-run")
    elif "--live" in args:
        dry_run = False
        args.remove("--live")

    if not args:
        print("Error: No command provided")
        sys.exit(1)

    # Get the query
    query = " ".join(args)

    # Create executor and run
    executor = NixDoExecutor(dry_run=dry_run)
    result = executor.execute(query)

    # Show result
    if result["success"]:
        print(f"\n‚úÖ {result['message']}")
        if "output" in result and result["output"]:
            print("\nOutput:")
            print(result["output"])
    else:
        print(f"\n‚ùå {result['message']}")
        if "error" in result:
            print(f"\nError: {result['error']}")

    return 0 if result["success"] else 1


if __name__ == "__main__":
    sys.exit(main())
