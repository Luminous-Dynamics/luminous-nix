#!/usr/bin/env python3
"""
Nix for Humanity - THE Unified Command (Refactored with Headless Architecture)
Natural language interface for NixOS with symbiotic learning capabilities

This version uses the headless engine through the CLI adapter while maintaining
all existing features and backward compatibility.
"""

import sys
import subprocess
import time
import threading
from pathlib import Path
import os
import json
import shutil
import tempfile
import argparse
from typing import Dict, Optional, Tuple, List
from datetime import datetime

# Add scripts directory to path
script_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'scripts'))
sys.path.insert(0, script_dir)

# Import the CLI adapter and context
from adapters.cli_adapter import CLIAdapter
from core.headless_engine import Context, ExecutionMode

# Try to import Rich for better visuals (graceful fallback)
try:
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
    from rich.panel import Panel
    from rich.table import Table
    from rich import print as rprint
    RICH_AVAILABLE = True
    console = Console()
except ImportError:
    RICH_AVAILABLE = False
    console = None
    rprint = print

class ProgressSpinner:
    """Simple progress spinner for long operations"""
    def __init__(self, message="Processing", estimated_time=None):
        self.message = message
        self.estimated_time = estimated_time
        self.running = False
        self.thread = None
        self.spinner_chars = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
        self.current = 0
        
    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self._spin)
        self.thread.start()
        
    def _spin(self):
        while self.running:
            time_info = f" (Est: {self.estimated_time})" if self.estimated_time else ""
            sys.stdout.write(f'\r{self.spinner_chars[self.current]} {self.message}{time_info}')
            sys.stdout.flush()
            self.current = (self.current + 1) % len(self.spinner_chars)
            time.sleep(0.1)
            
    def stop(self, final_message=None):
        self.running = False
        if self.thread:
            self.thread.join()
        sys.stdout.write('\r' + ' ' * 80 + '\r')  # Clear line
        if final_message:
            print(final_message)
        sys.stdout.flush()

class UnifiedNixAssistant:
    def __init__(self):
        # Initialize the CLI adapter with embedded engine (no server for now)
        self.adapter = CLIAdapter(use_server=False)
        self.dry_run = False  # Execute by default (Phase 1: Make It Real)
        self.visual_mode = RICH_AVAILABLE  # Use rich visuals if available
        self.progress_spinner = None
        
    def set_personality(self, personality: str):
        """Set the assistant personality"""
        # Will be applied when creating context
        self.personality = personality
        
    def set_mode(self, mode: str):
        """Set execution mode"""
        if mode == 'execute':
            self.dry_run = False
        elif mode == 'dry-run':
            self.dry_run = True
        elif mode == 'learning':
            self.dry_run = True  # Learning mode is always dry-run
            
    def process_query(self, query: str, personality: str = 'friendly', 
                     collect_feedback: bool = True, capabilities: List[str] = None) -> Dict:
        """Process a query using the headless engine"""
        # Create context
        if capabilities is None:
            capabilities = ['text']
            if self.visual_mode:
                capabilities.append('visual')
                
        context = Context(
            personality=personality,
            execution_mode=ExecutionMode.DRY_RUN if self.dry_run else ExecutionMode.SAFE,
            collect_feedback=collect_feedback,
            capabilities=capabilities
        )
        
        # Process through adapter
        return self.adapter.process_query(query, context)
    
    def display_response(self, response: Dict):
        """Display response to user"""
        if self.visual_mode and console:
            # Rich display
            console.print(Panel(response['text'], title="ü§ñ Response", border_style="blue"))
            
            if response.get('commands'):
                table = Table(title="üì¶ Commands")
                table.add_column("Command", style="cyan")
                for cmd in response['commands']:
                    table.add_row(cmd)
                console.print(table)
        else:
            # Plain display
            print(f"\n{response['text']}\n")
            
            if response.get('commands'):
                print("üì¶ Commands:")
                for cmd in response['commands']:
                    print(f"  $ {cmd}")
                print()
    
    def execute_commands(self, commands: List[str], response: Dict) -> bool:
        """Execute commands if not in dry-run mode"""
        if self.dry_run:
            print("\nüîç Dry-run mode - commands not executed")
            return True
            
        if not commands:
            return True
            
        # Show what we're about to do
        print("\nüöÄ Executing commands:")
        for cmd in commands:
            print(f"  $ {cmd}")
            
        # Confirm execution
        confirm = input("\nProceed? (y/N): ").strip().lower()
        if confirm != 'y':
            print("‚ùå Execution cancelled")
            return False
            
        # Execute each command
        success = True
        for cmd in commands:
            print(f"\n‚ñ∂Ô∏è  Running: {cmd}")
            
            # Start progress spinner
            if self.progress_spinner:
                self.progress_spinner.start()
                
            try:
                # Run command
                result = subprocess.run(
                    cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=300  # 5 minute timeout
                )
                
                # Stop spinner
                if self.progress_spinner:
                    self.progress_spinner.stop()
                    
                if result.returncode == 0:
                    print("‚úÖ Success!")
                    if result.stdout:
                        print(result.stdout)
                else:
                    print(f"‚ùå Failed with exit code {result.returncode}")
                    if result.stderr:
                        print(f"Error: {result.stderr}")
                    success = False
                    break
                    
            except subprocess.TimeoutExpired:
                if self.progress_spinner:
                    self.progress_spinner.stop()
                print("‚è±Ô∏è  Command timed out")
                success = False
                break
            except Exception as e:
                if self.progress_spinner:
                    self.progress_spinner.stop()
                print(f"‚ùå Error: {e}")
                success = False
                break
                
        return success
    
    def collect_feedback(self, response: Dict):
        """Collect user feedback"""
        if not response.get('feedback_request'):
            return
            
        feedback_request = response['feedback_request']
        prompt = feedback_request.get('prompt', 'Was this helpful?')
        
        print(f"\nüí¨ {prompt}")
        
        if feedback_request.get('type') == 'detailed':
            # Detailed feedback with options
            options = feedback_request.get('options', ['yes', 'no'])
            for i, option in enumerate(options, 1):
                print(f"  {i}. {option}")
                
            choice = input("Your choice (or press Enter to skip): ").strip()
            if choice:
                try:
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(options):
                        choice = options[choice_idx]
                        helpful = choice in ['perfect', 'helpful', 'yes']
                        
                        feedback = {
                            'query': response.get('intent', {}).get('query', ''),
                            'response': response.get('text', ''),
                            'helpful': helpful
                        }
                        
                        if not helpful:
                            improved = input("What would have been better? (or press Enter to skip): ").strip()
                            if improved:
                                feedback['improved_response'] = improved
                                
                        # Send feedback
                        if self.adapter.collect_feedback(response.get('session_id', ''), feedback):
                            print("‚úÖ Thank you for your feedback!")
                except (ValueError, IndexError):
                    pass
        else:
            # Simple yes/no
            helpful = input("(y/n): ").strip().lower() == 'y'
            
            feedback = {
                'query': response.get('intent', {}).get('query', ''),
                'response': response.get('text', ''),
                'helpful': helpful
            }
            
            if not helpful:
                improved = input("What would have been better? (or press Enter to skip): ").strip()
                if improved:
                    feedback['improved_response'] = improved
                    
            # Send feedback
            if self.adapter.collect_feedback(response.get('session_id', ''), feedback):
                print("‚úÖ Thank you for your feedback!")

def show_stats(adapter: CLIAdapter):
    """Show system statistics"""
    stats = adapter.get_stats()
    
    if RICH_AVAILABLE and console:
        table = Table(title="üìä System Statistics")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        
        table.add_row("Uptime", stats.get('uptime', 'N/A'))
        table.add_row("Active Sessions", str(stats.get('active_sessions', 0)))
        table.add_row("Plugins Loaded", str(stats.get('plugins_loaded', 0)))
        
        cache_stats = stats.get('cache_stats', {})
        table.add_row("Cached Packages", str(cache_stats.get('total_packages', 0)))
        
        feedback_stats = stats.get('feedback_stats', {})
        table.add_row("Total Feedback", str(feedback_stats.get('total', 0)))
        table.add_row("Helpfulness Rate", f"{feedback_stats.get('helpfulness_rate', 0):.1f}%")
        
        console.print(table)
    else:
        print("\nüìä System Statistics:")
        print(f"  Uptime: {stats.get('uptime', 'N/A')}")
        print(f"  Active Sessions: {stats.get('active_sessions', 0)}")
        print(f"  Plugins Loaded: {stats.get('plugins_loaded', 0)}")
        print(f"  Cached Packages: {stats.get('cache_stats', {}).get('total_packages', 0)}")
        print(f"  Total Feedback: {stats.get('feedback_stats', {}).get('total', 0)}")
        print(f"  Helpfulness Rate: {stats.get('feedback_stats', {}).get('helpfulness_rate', 0):.1f}%")

def main():
    parser = argparse.ArgumentParser(
        description='üó£Ô∏è Nix for Humanity - Natural Language NixOS Interface (v0.8.0)',
        epilog='Examples:\n'
               '  ask-nix "install firefox"\n'
               '  ask-nix --execute "update my system"\n'
               '  ask-nix --symbiotic "what\'s a generation?"\n'
               '  ask-nix --voice --encouraging\n',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Personality options
    personality_group = parser.add_mutually_exclusive_group()
    personality_group.add_argument('--minimal', action='store_true', 
                                 help='Just the facts, no fluff')
    personality_group.add_argument('--friendly', action='store_true', 
                                 help='Warm and helpful (default)')
    personality_group.add_argument('--encouraging', action='store_true', 
                                 help='Supportive for beginners')
    personality_group.add_argument('--technical', action='store_true', 
                                 help='Detailed technical explanations')
    personality_group.add_argument('--symbiotic', action='store_true', 
                                 help='üß¨ Co-evolutionary mode - learn together')
    
    # Execution modes
    exec_group = parser.add_mutually_exclusive_group()
    exec_group.add_argument('--execute', '-e', action='store_true',
                          help='Execute commands (carefully!)')
    exec_group.add_argument('--dry-run', '-n', action='store_true',
                          help='Show what would be done (default)')
    exec_group.add_argument('--learning-mode', '-l', action='store_true',
                          help='Step-by-step learning mode')
    
    # Other options
    parser.add_argument('--voice', '-v', action='store_true',
                      help='Enable voice interface (experimental)')
    parser.add_argument('--no-feedback', action='store_true',
                      help='Disable feedback collection')
    parser.add_argument('--no-cache', action='store_true',
                      help='Disable smart caching')
    parser.add_argument('--show-intent', action='store_true',
                      help='Show detected intent (debug)')
    parser.add_argument('--summary', action='store_true',
                      help='Show system statistics')
    parser.add_argument('--version', action='version',
                      version='%(prog)s 0.8.0 - Headless Architecture')
    
    # Query
    parser.add_argument('query', nargs='*', 
                      help='Your natural language query')
    
    args = parser.parse_args()
    
    # Handle special commands
    if args.summary:
        assistant = UnifiedNixAssistant()
        show_stats(assistant.adapter)
        return
        
    # Determine personality
    personality = 'friendly'  # default
    if args.minimal:
        personality = 'minimal'
    elif args.encouraging:
        personality = 'encouraging'
    elif args.technical:
        personality = 'technical'
    elif args.symbiotic:
        personality = 'symbiotic'
        
    # Create assistant
    assistant = UnifiedNixAssistant()
    
    # Set mode
    if args.execute:
        assistant.set_mode('execute')
    elif args.learning_mode:
        assistant.set_mode('learning')
    else:
        assistant.set_mode('dry-run')
        
    # Voice mode
    if args.voice:
        print("üé§ Voice interface coming soon! For now, type your query.")
        if not args.query:
            args.query = [input("‚ùì What would you like help with? ").strip()]
            
    # Process query
    if args.query:
        query = ' '.join(args.query)
        
        # Show progress
        if assistant.visual_mode:
            assistant.progress_spinner = ProgressSpinner("Processing your request")
            assistant.progress_spinner.start()
            
        try:
            # Process query
            response = assistant.process_query(
                query,
                personality=personality,
                collect_feedback=not args.no_feedback
            )
            
            # Stop spinner
            if assistant.progress_spinner:
                assistant.progress_spinner.stop()
                
            # Display response
            assistant.display_response(response)
            
            # Show intent if requested
            if args.show_intent and response.get('intent'):
                intent = response['intent']
                print(f"\nüéØ Intent: {intent.get('action', 'unknown')}")
                if intent.get('package'):
                    print(f"üì¶ Package: {intent['package']}")
                print(f"üîÆ Confidence: {response.get('confidence', 0):.1%}")
                
            # Execute commands if applicable
            if response.get('commands') and not args.dry_run:
                assistant.execute_commands(response['commands'], response)
                
            # Collect feedback
            if not args.no_feedback and response.get('feedback_request'):
                assistant.collect_feedback(response)
                
        except KeyboardInterrupt:
            if assistant.progress_spinner:
                assistant.progress_spinner.stop()
            print("\n\nüëã Cancelled")
        except Exception as e:
            if assistant.progress_spinner:
                assistant.progress_spinner.stop()
            print(f"\n‚ùå Error: {e}")
            if args.show_intent:
                import traceback
                traceback.print_exc()
    else:
        # Interactive mode
        print("üó£Ô∏è Nix for Humanity - Natural Language NixOS Interface")
        print("Type 'help' for assistance or 'exit' to quit\n")
        
        assistant.adapter.run_interactive(
            Context(
                personality=personality,
                execution_mode=ExecutionMode.SAFE if args.execute else ExecutionMode.DRY_RUN,
                collect_feedback=not args.no_feedback,
                capabilities=['text', 'visual'] if assistant.visual_mode else ['text']
            )
        )

if __name__ == "__main__":
    main()